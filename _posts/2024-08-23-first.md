---
layout: single
title:  "[기술 블로그 챌린지] 22일차 - 이진 검색 트리"
---

# 정의
- 이진 트리: 각 노드의 자식이 2개 이하인 트리
- 이진 검색 트리(Binary Search Tree): 왼쪽 서브트리의 모든 값은 부모의 값보다 작고 오른쪽 서브트리의 모든 값은 부모의 값보다 큰 이진 트리

# 성질
insert, erase, find, update 모두 O(lg N)
- Bc, 원소가 크기 순으로 정렬되어 있음

# 기능
1. insert
   현재 보고 있는 값과의 대소비교를 통해 빈 공간을 찾을 때 까지 왼쪽 혹은 오른쪽으로 계속 이동
2. find
   삽입과 비슷하게 루트에서 출발한 후 좌우로 움직이면 됨
3. erase
   - Case1. 자식이 없는 노드를 지울 때<br>
     그냥 지우면 됨
   - Case2. 자식이 1개인 노드를 지울 때<br>
     자식을 지워진 노드의 자리에 올림
   - Case3. 자식이 2개인 정점을 지울 때<br>
     지우고 싶은 원소에서 일단 오른쪽 자식을 보고 거기서부터 계속 왼쪽으로만 가면 됨


# 자가 균형 트리
: 대표적으로 AVL 트리, Red Black 트리

뭔가 불균형이 발생했을 때 트리를 꺾어버림<br>
-> 불균형을 없앰

이렇게 편향성을 해소해주는 자가 균형 트리를 사용할 때 비로소 이진 검색 트리에서 삽입, 검색, 삭제가 모두 O(lg N)이 됨


# STL
1. set
   - 원소가 정렬되어 있기 때문에 온갖 연산이 다 O(lg N)
   - lower_bound: 특정 원소가 삽입되어도 오름차순 순서가 그대로 유지되는 가장 왼쪽 위치
   - next, prev의 경우에는 정확히는 최악의 경우 O(lg N)이지만 amortized O(1)
2. multiset
   - 원소의 중복이 허용되는 STL
   - erase를 하면 15를 1개 지우는게 아니라 모든 15를 지운다는 점
   - iterator가 end()를 가리키고 있는데 거기의 값을 참조하도록 하는건 set/multiset/map에서 런타임 에러를 유발하는 주요 원인중 하나
3. map
   - key로 value를 찾는 인터페이스
